'''
This script converts a one-word-per-line input file in 2009 CoNLL format
to a factored corpus text file which can be read by gnmt.
'''

import logging
import argparse
import sys

NOT_APPLICABLE_ID = '3'
def load_wmap(path, inverse=False):
    with open(path) as f:
        d = dict(line.strip().split(None, 1) for line in f)
        if inverse:
            d = dict(zip(d.values(), d.keys()))
        for (s, i) in [('<s>', '1'), ('</s>', '2')]:
            if not s in d or d[s] != i:
                logging.warning("%s has not ID %s in word map %s!" % (s, i, path))
        return d

parser = argparse.ArgumentParser(description='Converts a morphological analysis in 2009 CoNLL format (e.g. generated by mate) '
                                 'to a factored corpus text file (indexed) which can be read by gnmt. '
                                 'Usage: python conll2factored.py < one-word-per-line-CoNLL > out_sens')
parser.add_argument('-s','--surface_wmap', help='Surface form word map to apply (format: see -i parameter)', required=False)
parser.add_argument('-l','--lemma_wmap', help='Lemma word map to apply (format: see -i parameter)', required=False)
parser.add_argument('-p','--pos_wmap', help='POS word map to apply (format: see -i parameter)', required=False)
parser.add_argument('-m','--morph_wmaps', help='Morphological word maps to apply (comma separated) (format: see -i parameter)', required=False)
parser.add_argument('-i','--inverse_wmap', help='Use this argument to use word maps with format "id word".'
                    ' Otherwise the format "word id" is assumed', action='store_true')
args = parser.parse_args()
SURFACE_COL = 1
LEMMA_COL = 3
POS_COL = 5
MORPH_COL = 7

base_wmaps = [(col, load_wmap(arg, args.inverse_wmap)) for (col, arg) in [
                   (SURFACE_COL, args.surface_wmap), 
                   (LEMMA_COL, args.lemma_wmap), 
                   (POS_COL, args.pos_wmap)] if arg]
morph_wmaps = [load_wmap(path, args.inverse_wmap) for path in args.morph_wmaps.split(',')]
for wmap in morph_wmaps:
    if wmap.get('<notapplicable>', -1) != NOT_APPLICABLE_ID:
        logging.error("Not applicable id is not %d" % NOT_APPLICABLE_ID)

unk = '0'

factors = []
for line in sys.stdin:
    parts = line.strip().split()
    if len(parts) < 2: # Sentence boundary
        print(' '.join(factors))
        factors = []
    else:
        if parts[LEMMA_COL] == '--':
            parts[LEMMA_COL] = parts[SURFACE_COL]
        base = [wmap.get(parts[col], unk) for (col, wmap) in base_wmaps]
        morph = len(morph_wmaps) * [NOT_APPLICABLE_ID]
        for f in parts[MORPH_COL].split("|"):
            for idx,wmap in enumerate(morph_wmaps):
                if f in wmap:
                    morph[idx] = wmap[f]
                    break
        factors.append(','.join(base + morph))
if factors:
  print(' '.join(factors))
